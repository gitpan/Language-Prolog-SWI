# This file was automatically generated by SWIG
package Language::Prolog::SWI;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package Language::Prolog::SWIc;
bootstrap Language::Prolog::SWI;
package Language::Prolog::SWI;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package Language::Prolog::SWI;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Language::Prolog::SWI;

*PlCall = *Language::Prolog::SWIc::PlCall;

############# Class : Language::Prolog::SWI::PlFunctor ##############

package Language::Prolog::SWI::PlFunctor;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_functor_get = *Language::Prolog::SWIc::PlFunctor_functor_get;
*swig_functor_set = *Language::Prolog::SWIc::PlFunctor_functor_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlFunctor(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlFunctor", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlFunctor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlAtom ##############

package Language::Prolog::SWI::PlAtom;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_handle_get = *Language::Prolog::SWIc::PlAtom_handle_get;
*swig_handle_set = *Language::Prolog::SWIc::PlAtom_handle_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlAtom(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlAtom", $self;
    return bless \%retval, $pkg;
}

*toString = *Language::Prolog::SWIc::PlAtom_toString;
*eq = *Language::Prolog::SWIc::PlAtom_eq;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlAtom($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlTerm ##############

package Language::Prolog::SWI::PlTerm;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_ref_get = *Language::Prolog::SWIc::PlTerm_ref_get;
*swig_ref_set = *Language::Prolog::SWIc::PlTerm_ref_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlTerm(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlTerm", $self;
    return bless \%retval, $pkg;
}

*toString = *Language::Prolog::SWIc::PlTerm_toString;
sub toPlAtom {
    my @args = @_;
    my $result = Language::Prolog::SWIc::PlTerm_toPlAtom(@args);
    return undef if (!defined($result));
    $Language::Prolog::SWI::PlAtom::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*type = *Language::Prolog::SWIc::PlTerm_type;
*arity = *Language::Prolog::SWIc::PlTerm_arity;
*name = *Language::Prolog::SWIc::PlTerm_name;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlTerm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlTermv ##############

package Language::Prolog::SWI::PlTermv;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_a0_get = *Language::Prolog::SWIc::PlTermv_a0_get;
*swig_a0_set = *Language::Prolog::SWIc::PlTermv_a0_set;
*swig_size_get = *Language::Prolog::SWIc::PlTermv_size_get;
*swig_size_set = *Language::Prolog::SWIc::PlTermv_size_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlTermv(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlTermv", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlTermv($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlCompound ##############

package Language::Prolog::SWI::PlCompound;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlCompound(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlCompound", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlCompound($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlString ##############

package Language::Prolog::SWI::PlString;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlString(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlString", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlCodeList ##############

package Language::Prolog::SWI::PlCodeList;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlCodeList(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlCodeList", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlCodeList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlCharList ##############

package Language::Prolog::SWI::PlCharList;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlCharList(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlCharList", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlCharList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlException ##############

package Language::Prolog::SWI::PlException;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlException(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlException", $self;
    return bless \%retval, $pkg;
}

*plThrow = *Language::Prolog::SWIc::PlException_plThrow;
*cppThrow = *Language::Prolog::SWIc::PlException_cppThrow;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlTypeError ##############

package Language::Prolog::SWI::PlTypeError;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlTypeError(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlTypeError", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlTypeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlDomainError ##############

package Language::Prolog::SWI::PlDomainError;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlDomainError(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlDomainError", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlDomainError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlTermvDomainError ##############

package Language::Prolog::SWI::PlTermvDomainError;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlTermvDomainError(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlTermvDomainError", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlTermvDomainError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlTail ##############

package Language::Prolog::SWI::PlTail;
@ISA = qw( Language::Prolog::SWI Language::Prolog::SWI::PlTerm );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlTail(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlTail", $self;
    return bless \%retval, $pkg;
}

*append = *Language::Prolog::SWIc::PlTail_append;
*close = *Language::Prolog::SWIc::PlTail_close;
*next = *Language::Prolog::SWIc::PlTail_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlTail($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : Language::Prolog::SWI::PlFrame ##############

package Language::Prolog::SWI::PlFrame;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_fid_get = *Language::Prolog::SWIc::PlFrame_fid_get;
*swig_fid_set = *Language::Prolog::SWIc::PlFrame_fid_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlFrame(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlFrame", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlFrame($self);
        delete $OWNER{$self};
    }
}

*rewind = *Language::Prolog::SWIc::PlFrame_rewind;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlQuery ##############

package Language::Prolog::SWI::PlQuery;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_qid_get = *Language::Prolog::SWIc::PlQuery_qid_get;
*swig_qid_set = *Language::Prolog::SWIc::PlQuery_qid_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlQuery(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlQuery", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlQuery($self);
        delete $OWNER{$self};
    }
}

*next_solution = *Language::Prolog::SWIc::PlQuery_next_solution;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlError ##############

package Language::Prolog::SWI::PlError;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*swig_message_get = *Language::Prolog::SWIc::PlError_message_get;
*swig_message_set = *Language::Prolog::SWIc::PlError_message_set;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlError(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlError", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : Language::Prolog::SWI::PlEngine ##############

package Language::Prolog::SWI::PlEngine;
@ISA = qw( Language::Prolog::SWI );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = Language::Prolog::SWIc::new_PlEngine(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Language::Prolog::SWI::PlEngine", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Language::Prolog::SWIc::delete_PlEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


# ------- VARIABLE STUBS --------

package Language::Prolog::SWI;

1;
